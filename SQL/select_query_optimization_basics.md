# Оптимизация SELECT запросов (Часть I - основы)

- нужно считывать ровно столько данных, сколько нужно. Не нужно использовать
 `SELECT *`, вместо этого надо указать необходимые колонки;
- добавить правильно спроектированные индексы ([основы индексов](https://t.me/DotnetBackendStudy/23), [советы по использованию индексов](https://t.me/DotnetBackendStudy/24));
- используйте `WHERE` вместо `HAVING`, т.к. `WHERE` сразу отсекает ненужные строки и в конечный набор попадают те, что попадают под условия, в то время как `HAVING` сначала формирует конечный набор из всех доступных строк, а только потом его фильтрует;
- при наличии `WHERE` фильтрации необходимо сначала поставить условие, которое отсечёт наибольшее количество строк, чтобы не убирать понемного, а разом убрать максимум неподходящих вариантов.
Т.е. запрос в идеале должен быть построен вот так:

```sql
SELECT Id
FROM Person
WHERE Surname = 'Ivanov' AND Name= 'Ivan'

//Это отработает быстрее, чем

SELECT Id
FROM Person
WHERE Name = 'Ivan' and Surname = 'Ivanov'
```

Т.к. Surname - это поле с более уникальным содержимым, соответственно сразу отсечёт больше нерелевантных строк.

- лучше использовать `IN` вместо `OR` при большом количестве сравниваемых значений - т.к. `IN` сортирует список и использует бинарный поиск, в то время как `OR` сравнивает значения в произвольном порядке

```sql
WHERE Name IN ('Ivan', 'Petr')

//вместо

WHERE Name = 'Ivan' OR Name = 'Petr'.
```

- дублирующийся код лучше инкапсулировать в хранимые процедуры. Во время первого её выполнения она будет оптимизирована и для неё будет создан план запроса. И при выполнении она будет вызываться из кэша, что увеличит производительность;
- используйте `EXISTS` вместо `COUNT > 0`, т.к. `EXISTS` выдаст `true` как только убедится, что существует хотя бы одна строка. В случае `COUNT > 0` - будут подсчитаны все строки.